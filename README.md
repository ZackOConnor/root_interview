# Root Interview

I started the problem like every problem: by breaking the problem into the problem statement, conditions, and requirements. 

Problem statement: Take in a .txt file and output an aggregated, sorted, list of drivers and their trip information
Conditions: I chose a text file in the command line, because I'm more familiar with that kind of input. Trip average mph must be between 5 and 100 mph, format of the commands, and the format of the timestamps.
Requirements: Desired output format aggregated by driver, sorted descending by miles driven, include mph, and for 0 miles drivers don't included mph

I understood the problem to be input a file, process it, and spit out a report. I modeled this process in my code. I created a class CommandProcessor which parses and prepared the inputted file, and a report method outside of the class to generate the output for the user. I chose to exclude the report method from within the CommandProcessor class because it felt like a nature evolution to later build a larger report class that could house different specific report methods if needed. Also, it seemed like more commands could be needed in the future, so I wanted to build in a structure that could easily handle adding and deleting valid commands.

Finding the right data structure to use was a bit of an internal debate. Ultimately, I considered three: lists, dictionaries, and data frames. 
I decided against list, because keeping track of a list of lists seemed error prone and looking up a driver would be expensive. A dictionary with drivers as a Key and a list of values as the value, had a cheap lookup but sorting and reporting the data would be complex.  Finally a data frame would have an expensive lookup and would be easy to sort and report out the data, but creating and updating the data would be inefficient. I decided to use a dict within CommandProceesor to keep track of the data and use Pandas to read this dictionary into a data frame in the report method. This seemed the best solution: cheap lookups and simple data updates while also creating a simple reporting process.

I created a constructor within CommandProcessor to set up the driver_dict, valid command list, and open the file. I created a process method that iterated through each line of the file, ran the lines through a parser, and sent the line to run_command. Here is where I created the ability to handle new commands. Instead of just using if else to run Trip or Driver, I built a method that takes the command from the parsed line, checked it against the valid command list, and runs the matching method. I also think this is a more logical way to lay out the code and to add a new command you just added it to the valid command list in the __init__, create the method, and name it appropriately.

The driver method returned a warning if the driver already existed, then added a new key/value pair to driver_dict if it didn't. The Trip method was a bit more complex. It raised an error and stopped the program if the driver didn't exist, then converted the elapsed time into minutes. The 24-hour format and not spanning day reduced complexity, and I decided to convert everything into minutes since that was the lowest level of information given and it eliminated the 60 minutes to 1-hour issue. Then, I calculated mile per hour (miles per minutes * 60) and checked it against the condition that the trip had an average mph  between 5 and 100 mph. I added the information to the matching driver in driver_dict as list elapsed minutes, miles driven. 

After processor was ran there exists a dict of all drivers and their summed trip information. Then, report is called passing in the driver_dict. The dict is read into a data frame, rounded to the nearest integer, sorted, and average mph is calculated and added. Now that the data frame is formatted correctly, I just ran over each row of the data frame to print out the user message for each driver in the required format. 

Testing was straightforward for most of the methods. I wrote unit test to test every aspect of the methods and mock test to make sure run_command was calling the correct methods. For me, testing the console output was new. I had to find and use new libraries I hadn't used before. I got them working and it allowed me to test report's output and write an end to end test.
